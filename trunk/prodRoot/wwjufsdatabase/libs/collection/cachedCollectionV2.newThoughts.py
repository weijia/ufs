import collectionInterface as collectionInterfaceimport collectionBase as collectionBaseclass cachableCollection(collectionInterface.readOnlyCollectionInterface):    def getCollectionUniversalId(self):        '''        Return an ID of the collection, so it can be identified by the cache system and the same object will not be cached twice.        '''        pass    def getRangeWithTimestamp(self, start, cnt, timestamp):        '''        Return a list with timestamp        '''        pass    def lastUpdated(self):        '''        Return a timestamp of the last update time        '''        passimport uuidimport libSysimport libs.utils.transform as transformdef getOriginalParent(childUrl, dbSysInst):    originalCollectionDb = dbSysInst.getOriginalCollectionDb()    parentItemDb = dbSysInst.getDb("parentItemDb")    try:        collectionId = parentItemDb[childUrl]    except KeyError:        import os        parent = os.path.dirname(transform.transformDirToInternal(childUrl))        try:            parentId = originalCollectionDb[parent][0]        except KeyError:            return parent        parentItemDb[childUrl] = parentId        return parent    #print collectionId    return originalCollectionDb[collectionId[0]][0]class simpleCacheCollection(collectionInterface.readOnlyCollectionInterface):    def __init__(self, dbSys, cachingCollection):        '''        This will create a new collection cache if the original was updated.        '''        self.dbSys = dbSys        self.targetCollectionId = cachingCollection.getCollectionUniversalId()        self.cachingCollection = cachingCollection        self.timeStamp = None    def hasElem(self, anElem):        raise "not supported yet"            def internalGetRange(self, start, cnt):        #url -> id        self.idDb = self.dbSys.getCollectionCacheIdDb()        #url -> updated time        self.updateDb = self.dbSys.getCollectionCacheUpdateDb()        #url -> items in collection        self.cachedCollectionDb = self.dbSys.getCollectionCacheDb()        #id -> url        self.originalCollectionDb = self.dbSys.getOriginalCollectionDb()        #child url -> parent id        self.parentItemDb = self.dbSys.getDb("parentItemDb")        updated = True        try:            #Collection already exist            cacheId = self.idDb[self.targetCollectionId][0]            #print 'cache ID is:',cacheId            lastUpdated = self.updateDb[self.targetCollectionId][0]            #print 'lastUpdated is:',lastUpdated            #print 'target collection updated?%s, %s'%(lastUpdated, self.cachingCollection.lastUpdated())            if self.cachingCollection.lastUpdated() == lastUpdated:                updated = False            else:                '''                #The collection was updated so create a new cache ID for it, as new added item will overwrite the old, delete is not necessary                #del self.idDb[self.targetCollectionId]                #del self.updateDb[self.targetCollectionId][0]                raise KeyError                '''                #Now only update the cache, not replace it with new one.        except KeyError:            #print 'new collection'            cacheId = unicode(uuid.uuid4())            #print 'cache ID is:',cacheId            self.idDb[self.targetCollectionId] = cacheId            lastUpdated = self.cachingCollection.lastUpdated()            self.updateDb[self.targetCollectionId] = lastUpdated            #print 'lastUpdated is:',lastUpdated            self.originalCollectionDb[cacheId] = self.targetCollectionId        if updated:            #Get existing items            existing = self.cachedCollectionDb[cacheId]            newItem = []            #The caching collection was updated, regenerate the cache            for i in self.cachingCollection.getRangeWithTimestamp(0, None, lastUpdated):                #print i                if i in existing:                    continue                newItem.append(i)                self.cachedCollectionDb.append(cacheId, i)                #print self.cachedCollectionDb[cacheId]                self.parentItemDb[i] = cacheId            for j in existing:                if not (j in newItem):                    self.cachedCollectionDb.remove(cacheId, j)                    self.parentItemDb.remove(j, cacheId)        #Init the collection Db member so other methods know how to access the DB        self.shoveListDb = self.cachedCollectionDb        self.collectionId = cacheId        #print '-----------------------------------------'        def getRange(self, start, cnt):        if self.timeStamp is None:            self.internalGetRange(start, cnt)            self.timeStamp = self.shoveListDb.getSnapshotTimestamp()        if cnt is None:            cnt = None        res = self.shoveListDb.getSnapshotValueRange(self.collectionId, self.timeStamp, start, cnt)        #res.append(self.collectionId)        return res        def main():    import localLibSys    import localLibs.test.testDbSys as testDbSys    res = {}    d = testDbSys.testDbSys()    c = u'D:/tmp/prodRoot/html/classtest_expando_1_1test_expando-members.html'    print "parent for: %s is:"%c,getOriginalParent(c, d)        if __name__=='__main__':    main()